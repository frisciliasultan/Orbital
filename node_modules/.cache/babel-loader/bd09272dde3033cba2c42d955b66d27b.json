{"ast":null,"code":"const getMod = require('./nusmods').getMod;\n\nconst assert = require('assert');\n\nconst parseMod = require('./parseMod');\n\nconst filterMods = require('./filterMods');\n\nfunction compile(ruleTag) {\n  if (typeof ruleTag == 'object') {\n    let ruleObj = ruleTag;\n\n    if (ruleObj.func === 'planned') {\n      return planned(ruleObj);\n    } else if (ruleObj.func === 'and') {\n      return and(ruleObj);\n    } else if (ruleObj.func === 'or') {\n      return or(ruleObj);\n    } else if (ruleObj.func === 'mcs') {\n      return mcs(ruleObj);\n    } else if (ruleObj.func === 'filter') {\n      return filter(ruleObj);\n    } else if (ruleObj.func === 'notEmpty') {\n      return notEmpty(ruleObj);\n    } else if (ruleObj.func === 'nTrue') {\n      return nTrue(ruleObj);\n    } else if (ruleObj.func === 'nModules') {\n      return nModules(ruleObj);\n    } else {\n      throw `func not recognised: ${ruleObj.func} in ${ruleObj.tag}`;\n    }\n  } else {\n    console.error('unrecognised ruleTag');\n  }\n} //Returns true if the mods listed contains the specified module\n\n\nfunction planned(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['moduleCode'] !== undefined);\n  const mod = params.moduleCode;\n  const noSuffix = parseMod(mod).no_suffix;\n  return modPlan => {\n    const noSuffixList = modPlan.modules.map(code => parseMod(code).no_suffix);\n    const bool = noSuffixList.includes(noSuffix);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Returns true if all of the sub functions return true\n\n\nasync function and(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['list'] !== undefined, '\"and\" list not provided');\n  const list = params.list;\n  var funcArray = await Promise.all(list.map(compile));\n  return async modPlan => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const bool = boolArray.every(bool => bool);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Returns true if at least one of the sub function returns true\n\n\nasync function or(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['list'] !== undefined);\n  const list = params.list;\n  var funcArray = await Promise.all(list.map(compile));\n  return async modPlan => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const bool = boolArray.includes(true);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Returns true if at least n of the sub functions return true, and less than or\n//equal to max of the sub functions return true\n\n\nasync function nTrue(ruleObj) {\n  var params = ruleObj.params; // Assert that at least one criteria is specified\n\n  assert(params['list'] !== undefined);\n  assert(params['min'] !== undefined || params['max'] !== undefined || params['equal'] !== undefined); // Parse and set the constraints\n\n  var min, max, equal;\n\n  if (params.min) {\n    min = typeof params.min == 'string' ? parseInt(params.min) : params.min;\n  }\n\n  if (params.max) {\n    max = typeof params.max == 'string' ? parseInt(params.max) : params.max;\n  }\n\n  if (params.equal) {\n    equal = typeof params.equal == 'string' ? parseInt(params.equal) : params.equal;\n  }\n\n  const list = params.list;\n  var funcArray = await Promise.all(list.map(compile));\n  return async modPlan => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const n = boolArray.reduce((a, b) => a + b, 0);\n\n    if (min !== undefined && n < min) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    }\n\n    if (max !== undefined && n > max) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    }\n\n    if (equal !== undefined && n !== equal) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    }\n\n    ruleObj.evaluation = true;\n    return ruleObj;\n  };\n} //Returns true if the mods listed meet the number of MCs stated\n\n\nasync function mcs(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['min'] !== undefined || params['max'] !== undefined || params['equal'] !== undefined); // Parse and set the constraints\n\n  var min, max, equal;\n\n  if (params.min) {\n    min = typeof params.min == 'string' ? parseInt(params.min) : params.min;\n  }\n\n  if (params.max) {\n    max = typeof params.max == 'string' ? parseInt(params.max) : params.max;\n  }\n\n  if (params.equal) {\n    equal = typeof params.equal == 'string' ? parseInt(params.equal) : params.equal;\n  }\n\n  return async modPlan => {\n    var modList = modPlan.modules;\n\n    if (params.filter !== undefined) {\n      if (Array.isArray(params.filter)) {\n        modList = filterMods(modList, ...params.filter);\n      } else if (typeof params.filter == 'object') {\n        modList = filterMods(modList, params.filter);\n      }\n    }\n\n    const promiseArr = modList.map(code => getMod(2018, code));\n    const creditArr = await Promise.all(promiseArr);\n    const n = creditArr.map(item => parseInt(item.moduleCredit)).reduce((a, b) => a + b, 0);\n\n    if (min !== undefined && n < min) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    }\n\n    if (max !== undefined && n > max) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    }\n\n    if (equal !== undefined && n !== equal) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    }\n\n    ruleObj.evaluation = true;\n    return ruleObj;\n  };\n} //Checks if the modPlan contains at least n number of modules\n\n\nasync function nModules(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['min'] !== undefined || params['max'] !== undefined || params['equal'] !== undefined, \"in \" + ruleObj); // Parse and set the constraints\n\n  var min, max, equal;\n\n  if (params.min) {\n    min = typeof params.min == 'string' ? parseInt(params.min) : params.min;\n  }\n\n  if (params.max) {\n    max = typeof params.max == 'string' ? parseInt(params.max) : params.max;\n  }\n\n  if (params.equal) {\n    equal = typeof params.equal == 'string' ? parseInt(params.equal) : params.equal;\n  }\n\n  return modPlan => {\n    var filteredModules = modPlan.modules;\n\n    if (params.filter !== undefined) {\n      if (Array.isArray(params.filter)) {\n        filteredModules = filterMods(filteredModules, ...params.filter);\n      } else if (typeof params.filter == 'object') {\n        filteredModules = filterMods(filteredModules, params.filter);\n      }\n    }\n\n    const n = filteredModules.length;\n\n    if (min !== undefined && n < min) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    }\n\n    if (max !== undefined && n > max) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    }\n\n    if (equal !== undefined && n !== equal) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    }\n\n    ruleObj.evaluation = true;\n    return ruleObj;\n  };\n} //Checks if the modPlan is not empty\n\n\nasync function notEmpty(ruleObj) {\n  var params = ruleObj.params;\n  return modPlan => {\n    var filteredModules = modPlan.modules;\n\n    if (params.filter !== undefined) {\n      if (Array.isArray(params.filter)) {\n        filteredModules = filterMods(filteredModules, ...params.filter);\n      } else if (typeof params.filter == 'object') {\n        filteredModules = filterMods(filteredModules, params.filter);\n      }\n    }\n\n    const bool = filteredModules.length !== 0;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Filters the modPlan for certain modules and passes it to the next function\n//Filtering happens in the following sequence:\n//First only allow the specified modules\n//Then filter by prefix and level\n//Then reintroduced the excepted modules\n\n\nasync function filter(ruleObj) {\n  var params = ruleObj.params;\n\n  function checkFor(moduleCode, attribute, acceptedVals) {\n    let key = parseMod(moduleCode)[attribute];\n    assert(key !== undefined);\n    return acceptedVals.includes(key);\n  }\n\n  assert(params.next !== undefined);\n  var nextFunc = await compile(params.next);\n  return async modPlan => {\n    var modList = modPlan.modules;\n\n    if (params.modules !== undefined) {\n      const allowed = params.modules;\n      modList = modList.filter(mod => allowed.includes(mod));\n    }\n\n    if (params.prefix !== undefined) {\n      const allowed = typeof params.prefix === 'string' ? [params.prefix] : params.prefix;\n      modList = modList.filter(mod => checkFor(mod, 'prefix', allowed));\n    }\n\n    if (params.level !== undefined) {\n      const allowed = (typeof params.level === 'object' ? params.level : [params.level]).map(item => item.toString());\n      modList = modList.filter(mod => checkFor(mod, 'level', allowed));\n    }\n\n    if (params.type !== undefined) {\n      const allowed = (typeof params.type === 'object' ? params.type : [params.type]).map(item => item.toString());\n      modList = modList.filter(mod => checkFor(mod, 'type', allowed));\n    }\n\n    if (params.block !== undefined) {\n      const blocked = params.block;\n      modList = modList.filter(mod => !blocked.includes(mod));\n    }\n\n    if (params.allow !== undefined) {\n      const allowed = params.allow;\n      const exception = modPlan.modules.filter(mod => allowed.includes(mod));\n      modList = modList.concat(exception);\n    }\n\n    var deepCopy = JSON.parse(JSON.stringify(modPlan));\n    deepCopy.modules = modList;\n    const nextObj = await nextFunc(deepCopy);\n    const bool = nextObj.evaluation;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n}\n\nmodule.exports = compile;","map":{"version":3,"sources":["/Users/frisciliasultan/Documents/Orbitalhosting/src/backend_utils/compile.js"],"names":["getMod","require","assert","parseMod","filterMods","compile","ruleTag","ruleObj","func","planned","and","or","mcs","filter","notEmpty","nTrue","nModules","tag","console","error","params","undefined","mod","moduleCode","noSuffix","no_suffix","modPlan","noSuffixList","modules","map","code","bool","includes","evaluation","list","funcArray","Promise","all","objArray","boolArray","obj","every","min","max","equal","parseInt","n","reduce","a","b","modList","Array","isArray","promiseArr","creditArr","item","moduleCredit","filteredModules","length","checkFor","attribute","acceptedVals","key","next","nextFunc","allowed","prefix","level","toString","type","block","blocked","allow","exception","concat","deepCopy","JSON","parse","stringify","nextObj","module","exports"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAP,CAAqBD,MAApC;;AACA,MAAME,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,cAAD,CAA1B;;AAEA,SAASI,OAAT,CAAiBC,OAAjB,EAA0B;AACxB,MAAI,OAAOA,OAAP,IAAkB,QAAtB,EAAgC;AAC9B,QAAIC,OAAO,GAAGD,OAAd;;AACA,QAAIC,OAAO,CAACC,IAAR,KAAiB,SAArB,EAAgC;AAC9B,aAAOC,OAAO,CAACF,OAAD,CAAd;AACD,KAFD,MAEO,IAAIA,OAAO,CAACC,IAAR,KAAiB,KAArB,EAA4B;AACjC,aAAOE,GAAG,CAACH,OAAD,CAAV;AACD,KAFM,MAEA,IAAIA,OAAO,CAACC,IAAR,KAAiB,IAArB,EAA2B;AAChC,aAAOG,EAAE,CAACJ,OAAD,CAAT;AACD,KAFM,MAEA,IAAIA,OAAO,CAACC,IAAR,KAAiB,KAArB,EAA4B;AACjC,aAAOI,GAAG,CAACL,OAAD,CAAV;AACD,KAFM,MAEA,IAAIA,OAAO,CAACC,IAAR,KAAiB,QAArB,EAA+B;AACpC,aAAOK,MAAM,CAACN,OAAD,CAAb;AACD,KAFM,MAEA,IAAIA,OAAO,CAACC,IAAR,KAAiB,UAArB,EAAiC;AACtC,aAAOM,QAAQ,CAACP,OAAD,CAAf;AACD,KAFM,MAEA,IAAIA,OAAO,CAACC,IAAR,KAAiB,OAArB,EAA8B;AACnC,aAAOO,KAAK,CAACR,OAAD,CAAZ;AACD,KAFM,MAEA,IAAIA,OAAO,CAACC,IAAR,KAAiB,UAArB,EAAiC;AACtC,aAAOQ,QAAQ,CAACT,OAAD,CAAf;AACD,KAFM,MAEA;AACL,YAAO,wBAAuBA,OAAO,CAACC,IAAK,OAAMD,OAAO,CAACU,GAAI,EAA7D;AACD;AACF,GArBD,MAqBO;AACLC,IAAAA,OAAO,CAACC,KAAR,CAAc,sBAAd;AACD;AACF,C,CAED;;;AACA,SAASV,OAAT,CAAiBF,OAAjB,EAA0B;AACxB,MAAIa,MAAM,GAAGb,OAAO,CAACa,MAArB;AACAlB,EAAAA,MAAM,CAACkB,MAAM,CAAC,YAAD,CAAN,KAAyBC,SAA1B,CAAN;AACA,QAAMC,GAAG,GAAGF,MAAM,CAACG,UAAnB;AACA,QAAMC,QAAQ,GAAGrB,QAAQ,CAACmB,GAAD,CAAR,CAAcG,SAA/B;AACA,SAAQC,OAAD,IAAa;AAClB,UAAMC,YAAY,GAAGD,OAAO,CAACE,OAAR,CAAgBC,GAAhB,CAAoBC,IAAI,IAAI3B,QAAQ,CAAC2B,IAAD,CAAR,CAAeL,SAA3C,CAArB;AACA,UAAMM,IAAI,GAAGJ,YAAY,CAACK,QAAb,CAAsBR,QAAtB,CAAb;AACAjB,IAAAA,OAAO,CAAC0B,UAAR,GAAqBF,IAArB;AACA,WAAOxB,OAAP;AACD,GALD;AAMD,C,CAED;;;AACA,eAAeG,GAAf,CAAmBH,OAAnB,EAA4B;AAC1B,MAAIa,MAAM,GAAGb,OAAO,CAACa,MAArB;AACAlB,EAAAA,MAAM,CAACkB,MAAM,CAAC,MAAD,CAAN,KAAmBC,SAApB,EAA+B,yBAA/B,CAAN;AACA,QAAMa,IAAI,GAAGd,MAAM,CAACc,IAApB;AACA,MAAIC,SAAS,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYH,IAAI,CAACL,GAAL,CAASxB,OAAT,CAAZ,CAAtB;AACA,SAAO,MAAOqB,OAAP,IAAmB;AACxB,QAAIY,QAAQ,GAAG,MAAMF,OAAO,CAACC,GAAR,CAAYF,SAAS,CAACN,GAAV,CAAcrB,IAAI,IAAIA,IAAI,CAACkB,OAAD,CAA1B,CAAZ,CAArB;AACA,UAAMa,SAAS,GAAGD,QAAQ,CAACT,GAAT,CAAaW,GAAG,IAAIA,GAAG,CAACP,UAAxB,CAAlB;AACA,UAAMF,IAAI,GAAGQ,SAAS,CAACE,KAAV,CAAgBV,IAAI,IAAIA,IAAxB,CAAb;AACAxB,IAAAA,OAAO,CAAC0B,UAAR,GAAqBF,IAArB;AACA,WAAOxB,OAAP;AACD,GAND;AAOD,C,CAED;;;AACA,eAAeI,EAAf,CAAkBJ,OAAlB,EAA2B;AACzB,MAAIa,MAAM,GAAGb,OAAO,CAACa,MAArB;AACAlB,EAAAA,MAAM,CAACkB,MAAM,CAAC,MAAD,CAAN,KAAmBC,SAApB,CAAN;AACA,QAAMa,IAAI,GAAGd,MAAM,CAACc,IAApB;AACA,MAAIC,SAAS,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYH,IAAI,CAACL,GAAL,CAASxB,OAAT,CAAZ,CAAtB;AACA,SAAO,MAAOqB,OAAP,IAAmB;AACxB,QAAIY,QAAQ,GAAG,MAAMF,OAAO,CAACC,GAAR,CAAYF,SAAS,CAACN,GAAV,CAAcrB,IAAI,IAAIA,IAAI,CAACkB,OAAD,CAA1B,CAAZ,CAArB;AACA,UAAMa,SAAS,GAAGD,QAAQ,CAACT,GAAT,CAAaW,GAAG,IAAIA,GAAG,CAACP,UAAxB,CAAlB;AACA,UAAMF,IAAI,GAAGQ,SAAS,CAACP,QAAV,CAAmB,IAAnB,CAAb;AACAzB,IAAAA,OAAO,CAAC0B,UAAR,GAAqBF,IAArB;AACA,WAAOxB,OAAP;AACD,GAND;AAOD,C,CAED;AACA;;;AACA,eAAeQ,KAAf,CAAqBR,OAArB,EAA8B;AAC5B,MAAIa,MAAM,GAAGb,OAAO,CAACa,MAArB,CAD4B,CAG5B;;AACAlB,EAAAA,MAAM,CAACkB,MAAM,CAAC,MAAD,CAAN,KAAmBC,SAApB,CAAN;AACAnB,EAAAA,MAAM,CACJkB,MAAM,CAAC,KAAD,CAAN,KAAkBC,SAAlB,IACAD,MAAM,CAAC,KAAD,CAAN,KAAkBC,SADlB,IAEAD,MAAM,CAAC,OAAD,CAAN,KAAoBC,SAHhB,CAAN,CAL4B,CAU5B;;AACA,MAAIqB,GAAJ,EAASC,GAAT,EAAcC,KAAd;;AACA,MAAIxB,MAAM,CAACsB,GAAX,EAAgB;AACdA,IAAAA,GAAG,GAAG,OAAOtB,MAAM,CAACsB,GAAd,IAAqB,QAArB,GACJG,QAAQ,CAACzB,MAAM,CAACsB,GAAR,CADJ,GAEJtB,MAAM,CAACsB,GAFT;AAGD;;AACD,MAAItB,MAAM,CAACuB,GAAX,EAAgB;AACdA,IAAAA,GAAG,GAAG,OAAOvB,MAAM,CAACuB,GAAd,IAAqB,QAArB,GACJE,QAAQ,CAACzB,MAAM,CAACuB,GAAR,CADJ,GAEJvB,MAAM,CAACuB,GAFT;AAGD;;AACD,MAAIvB,MAAM,CAACwB,KAAX,EAAkB;AAChBA,IAAAA,KAAK,GAAG,OAAOxB,MAAM,CAACwB,KAAd,IAAuB,QAAvB,GACNC,QAAQ,CAACzB,MAAM,CAACwB,KAAR,CADF,GAENxB,MAAM,CAACwB,KAFT;AAGD;;AAED,QAAMV,IAAI,GAAGd,MAAM,CAACc,IAApB;AACA,MAAIC,SAAS,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYH,IAAI,CAACL,GAAL,CAASxB,OAAT,CAAZ,CAAtB;AACA,SAAO,MAAOqB,OAAP,IAAmB;AACxB,QAAIY,QAAQ,GAAG,MAAMF,OAAO,CAACC,GAAR,CAAYF,SAAS,CAACN,GAAV,CAAcrB,IAAI,IAAIA,IAAI,CAACkB,OAAD,CAA1B,CAAZ,CAArB;AACA,UAAMa,SAAS,GAAGD,QAAQ,CAACT,GAAT,CAAaW,GAAG,IAAIA,GAAG,CAACP,UAAxB,CAAlB;AACA,UAAMa,CAAC,GAAGP,SAAS,CAACQ,MAAV,CAAiB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAA/B,EAAkC,CAAlC,CAAV;;AAEA,QAAIP,GAAG,KAAKrB,SAAR,IAAqByB,CAAC,GAAGJ,GAA7B,EAAkC;AAChCnC,MAAAA,OAAO,CAAC0B,UAAR,GAAqB,KAArB;AACA,aAAO1B,OAAP;AACD;;AACD,QAAIoC,GAAG,KAAKtB,SAAR,IAAqByB,CAAC,GAAGH,GAA7B,EAAkC;AAChCpC,MAAAA,OAAO,CAAC0B,UAAR,GAAqB,KAArB;AACA,aAAO1B,OAAP;AACD;;AACD,QAAIqC,KAAK,KAAKvB,SAAV,IAAuByB,CAAC,KAAKF,KAAjC,EAAwC;AACtCrC,MAAAA,OAAO,CAAC0B,UAAR,GAAqB,KAArB;AACA,aAAO1B,OAAP;AACD;;AACDA,IAAAA,OAAO,CAAC0B,UAAR,GAAqB,IAArB;AACA,WAAO1B,OAAP;AAED,GApBD;AAqBD,C,CAED;;;AACA,eAAeK,GAAf,CAAmBL,OAAnB,EAA4B;AAC1B,MAAIa,MAAM,GAAGb,OAAO,CAACa,MAArB;AAEAlB,EAAAA,MAAM,CACJkB,MAAM,CAAC,KAAD,CAAN,KAAkBC,SAAlB,IACAD,MAAM,CAAC,KAAD,CAAN,KAAkBC,SADlB,IAEAD,MAAM,CAAC,OAAD,CAAN,KAAoBC,SAHhB,CAAN,CAH0B,CAO1B;;AACA,MAAIqB,GAAJ,EAASC,GAAT,EAAcC,KAAd;;AACA,MAAIxB,MAAM,CAACsB,GAAX,EAAgB;AACdA,IAAAA,GAAG,GAAG,OAAOtB,MAAM,CAACsB,GAAd,IAAqB,QAArB,GACJG,QAAQ,CAACzB,MAAM,CAACsB,GAAR,CADJ,GAEJtB,MAAM,CAACsB,GAFT;AAGD;;AACD,MAAItB,MAAM,CAACuB,GAAX,EAAgB;AACdA,IAAAA,GAAG,GAAG,OAAOvB,MAAM,CAACuB,GAAd,IAAqB,QAArB,GACJE,QAAQ,CAACzB,MAAM,CAACuB,GAAR,CADJ,GAEJvB,MAAM,CAACuB,GAFT;AAGD;;AACD,MAAIvB,MAAM,CAACwB,KAAX,EAAkB;AAChBA,IAAAA,KAAK,GAAG,OAAOxB,MAAM,CAACwB,KAAd,IAAuB,QAAvB,GACNC,QAAQ,CAACzB,MAAM,CAACwB,KAAR,CADF,GAENxB,MAAM,CAACwB,KAFT;AAGD;;AAED,SAAO,MAAOlB,OAAP,IAAmB;AACxB,QAAIwB,OAAO,GAAGxB,OAAO,CAACE,OAAtB;;AACA,QAAIR,MAAM,CAACP,MAAP,KAAkBQ,SAAtB,EAAiC;AAC/B,UAAI8B,KAAK,CAACC,OAAN,CAAchC,MAAM,CAACP,MAArB,CAAJ,EAAkC;AAChCqC,QAAAA,OAAO,GAAG9C,UAAU,CAAC8C,OAAD,EAAU,GAAG9B,MAAM,CAACP,MAApB,CAApB;AACD,OAFD,MAEO,IAAI,OAAOO,MAAM,CAACP,MAAd,IAAwB,QAA5B,EAAsC;AAC3CqC,QAAAA,OAAO,GAAG9C,UAAU,CAAC8C,OAAD,EAAU9B,MAAM,CAACP,MAAjB,CAApB;AACD;AACF;;AACD,UAAMwC,UAAU,GAAGH,OAAO,CAACrB,GAAR,CAAYC,IAAI,IAAI9B,MAAM,CAAC,IAAD,EAAO8B,IAAP,CAA1B,CAAnB;AACA,UAAMwB,SAAS,GAAG,MAAMlB,OAAO,CAACC,GAAR,CAAYgB,UAAZ,CAAxB;AACA,UAAMP,CAAC,GAAGQ,SAAS,CAACzB,GAAV,CAAc0B,IAAI,IAAIV,QAAQ,CAACU,IAAI,CAACC,YAAN,CAA9B,EAAmDT,MAAnD,CAA0D,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAxE,EAA2E,CAA3E,CAAV;;AAEA,QAAIP,GAAG,KAAKrB,SAAR,IAAqByB,CAAC,GAAGJ,GAA7B,EAAkC;AAChCnC,MAAAA,OAAO,CAAC0B,UAAR,GAAqB,KAArB;AACA,aAAO1B,OAAP;AACD;;AACD,QAAIoC,GAAG,KAAKtB,SAAR,IAAqByB,CAAC,GAAGH,GAA7B,EAAkC;AAChCpC,MAAAA,OAAO,CAAC0B,UAAR,GAAqB,KAArB;AACA,aAAO1B,OAAP;AACD;;AACD,QAAIqC,KAAK,KAAKvB,SAAV,IAAuByB,CAAC,KAAKF,KAAjC,EAAwC;AACtCrC,MAAAA,OAAO,CAAC0B,UAAR,GAAqB,KAArB;AACA,aAAO1B,OAAP;AACD;;AACDA,IAAAA,OAAO,CAAC0B,UAAR,GAAqB,IAArB;AACA,WAAO1B,OAAP;AAED,GA5BD;AA6BD,C,CAED;;;AACA,eAAeS,QAAf,CAAyBT,OAAzB,EAAkC;AAChC,MAAIa,MAAM,GAAGb,OAAO,CAACa,MAArB;AAEAlB,EAAAA,MAAM,CACJkB,MAAM,CAAC,KAAD,CAAN,KAAkBC,SAAlB,IACAD,MAAM,CAAC,KAAD,CAAN,KAAkBC,SADlB,IAEAD,MAAM,CAAC,OAAD,CAAN,KAAoBC,SAHhB,EAG2B,QAAQd,OAHnC,CAAN,CAHgC,CAOhC;;AACA,MAAImC,GAAJ,EAASC,GAAT,EAAcC,KAAd;;AACA,MAAIxB,MAAM,CAACsB,GAAX,EAAgB;AACdA,IAAAA,GAAG,GAAG,OAAOtB,MAAM,CAACsB,GAAd,IAAqB,QAArB,GACJG,QAAQ,CAACzB,MAAM,CAACsB,GAAR,CADJ,GAEJtB,MAAM,CAACsB,GAFT;AAGD;;AACD,MAAItB,MAAM,CAACuB,GAAX,EAAgB;AACdA,IAAAA,GAAG,GAAG,OAAOvB,MAAM,CAACuB,GAAd,IAAqB,QAArB,GACJE,QAAQ,CAACzB,MAAM,CAACuB,GAAR,CADJ,GAEJvB,MAAM,CAACuB,GAFT;AAGD;;AACD,MAAIvB,MAAM,CAACwB,KAAX,EAAkB;AAChBA,IAAAA,KAAK,GAAG,OAAOxB,MAAM,CAACwB,KAAd,IAAuB,QAAvB,GACNC,QAAQ,CAACzB,MAAM,CAACwB,KAAR,CADF,GAENxB,MAAM,CAACwB,KAFT;AAGD;;AAED,SAAQlB,OAAD,IAAa;AAClB,QAAI+B,eAAe,GAAG/B,OAAO,CAACE,OAA9B;;AACA,QAAIR,MAAM,CAACP,MAAP,KAAkBQ,SAAtB,EAAiC;AAC/B,UAAI8B,KAAK,CAACC,OAAN,CAAchC,MAAM,CAACP,MAArB,CAAJ,EAAkC;AAChC4C,QAAAA,eAAe,GAAGrD,UAAU,CAACqD,eAAD,EAAkB,GAAGrC,MAAM,CAACP,MAA5B,CAA5B;AACD,OAFD,MAEO,IAAI,OAAOO,MAAM,CAACP,MAAd,IAAwB,QAA5B,EAAsC;AAC3C4C,QAAAA,eAAe,GAAGrD,UAAU,CAACqD,eAAD,EAAkBrC,MAAM,CAACP,MAAzB,CAA5B;AACD;AACF;;AACD,UAAMiC,CAAC,GAAGW,eAAe,CAACC,MAA1B;;AAEA,QAAIhB,GAAG,KAAKrB,SAAR,IAAqByB,CAAC,GAAGJ,GAA7B,EAAkC;AAChCnC,MAAAA,OAAO,CAAC0B,UAAR,GAAqB,KAArB;AACA,aAAO1B,OAAP;AACD;;AACD,QAAIoC,GAAG,KAAKtB,SAAR,IAAqByB,CAAC,GAAGH,GAA7B,EAAkC;AAChCpC,MAAAA,OAAO,CAAC0B,UAAR,GAAqB,KAArB;AACA,aAAO1B,OAAP;AACD;;AACD,QAAIqC,KAAK,KAAKvB,SAAV,IAAuByB,CAAC,KAAKF,KAAjC,EAAwC;AACtCrC,MAAAA,OAAO,CAAC0B,UAAR,GAAqB,KAArB;AACA,aAAO1B,OAAP;AACD;;AACDA,IAAAA,OAAO,CAAC0B,UAAR,GAAqB,IAArB;AACA,WAAO1B,OAAP;AAED,GA1BD;AA2BD,C,CAED;;;AACA,eAAeO,QAAf,CAAyBP,OAAzB,EAAkC;AAChC,MAAIa,MAAM,GAAGb,OAAO,CAACa,MAArB;AACA,SAAQM,OAAD,IAAa;AAClB,QAAI+B,eAAe,GAAG/B,OAAO,CAACE,OAA9B;;AACA,QAAIR,MAAM,CAACP,MAAP,KAAkBQ,SAAtB,EAAiC;AAC/B,UAAI8B,KAAK,CAACC,OAAN,CAAchC,MAAM,CAACP,MAArB,CAAJ,EAAkC;AAChC4C,QAAAA,eAAe,GAAGrD,UAAU,CAACqD,eAAD,EAAkB,GAAGrC,MAAM,CAACP,MAA5B,CAA5B;AACD,OAFD,MAEO,IAAI,OAAOO,MAAM,CAACP,MAAd,IAAwB,QAA5B,EAAsC;AAC3C4C,QAAAA,eAAe,GAAGrD,UAAU,CAACqD,eAAD,EAAkBrC,MAAM,CAACP,MAAzB,CAA5B;AACD;AACF;;AACD,UAAMkB,IAAI,GAAI0B,eAAe,CAACC,MAAhB,KAA2B,CAAzC;AACAnD,IAAAA,OAAO,CAAC0B,UAAR,GAAqBF,IAArB;AACA,WAAOxB,OAAP;AACD,GAZD;AAaD,C,CAED;AACA;AACA;AACA;AACA;;;AACA,eAAeM,MAAf,CAAsBN,OAAtB,EAA+B;AAC7B,MAAIa,MAAM,GAAGb,OAAO,CAACa,MAArB;;AAEA,WAASuC,QAAT,CAAmBpC,UAAnB,EAA+BqC,SAA/B,EAA0CC,YAA1C,EAAwD;AACtD,QAAIC,GAAG,GAAG3D,QAAQ,CAACoB,UAAD,CAAR,CAAqBqC,SAArB,CAAV;AACA1D,IAAAA,MAAM,CAAC4D,GAAG,KAAKzC,SAAT,CAAN;AACA,WAAOwC,YAAY,CAAC7B,QAAb,CAAsB8B,GAAtB,CAAP;AACD;;AAED5D,EAAAA,MAAM,CAACkB,MAAM,CAAC2C,IAAP,KAAgB1C,SAAjB,CAAN;AACA,MAAI2C,QAAQ,GAAG,MAAM3D,OAAO,CAACe,MAAM,CAAC2C,IAAR,CAA5B;AAEA,SAAO,MAAMrC,OAAN,IAAiB;AACtB,QAAIwB,OAAO,GAAGxB,OAAO,CAACE,OAAtB;;AAEA,QAAIR,MAAM,CAACQ,OAAP,KAAmBP,SAAvB,EAAkC;AAChC,YAAM4C,OAAO,GAAG7C,MAAM,CAACQ,OAAvB;AACAsB,MAAAA,OAAO,GAAGA,OAAO,CAACrC,MAAR,CAAeS,GAAG,IAAI2C,OAAO,CAACjC,QAAR,CAAiBV,GAAjB,CAAtB,CAAV;AACD;;AAED,QAAIF,MAAM,CAAC8C,MAAP,KAAkB7C,SAAtB,EAAiC;AAC/B,YAAM4C,OAAO,GAAG,OAAO7C,MAAM,CAAC8C,MAAd,KAAyB,QAAzB,GACZ,CAAC9C,MAAM,CAAC8C,MAAR,CADY,GAEZ9C,MAAM,CAAC8C,MAFX;AAGAhB,MAAAA,OAAO,GAAGA,OAAO,CAACrC,MAAR,CAAeS,GAAG,IAAIqC,QAAQ,CAACrC,GAAD,EAAM,QAAN,EAAgB2C,OAAhB,CAA9B,CAAV;AACD;;AAED,QAAI7C,MAAM,CAAC+C,KAAP,KAAiB9C,SAArB,EAAgC;AAC9B,YAAM4C,OAAO,GAAG,CAAC,OAAO7C,MAAM,CAAC+C,KAAd,KAAwB,QAAxB,GACb/C,MAAM,CAAC+C,KADM,GAEb,CAAC/C,MAAM,CAAC+C,KAAR,CAFY,EAEItC,GAFJ,CAEQ0B,IAAI,IAAIA,IAAI,CAACa,QAAL,EAFhB,CAAhB;AAGAlB,MAAAA,OAAO,GAAGA,OAAO,CAACrC,MAAR,CAAeS,GAAG,IAAIqC,QAAQ,CAACrC,GAAD,EAAM,OAAN,EAAe2C,OAAf,CAA9B,CAAV;AACD;;AAED,QAAI7C,MAAM,CAACiD,IAAP,KAAgBhD,SAApB,EAA+B;AAC7B,YAAM4C,OAAO,GAAG,CAAC,OAAO7C,MAAM,CAACiD,IAAd,KAAuB,QAAvB,GACbjD,MAAM,CAACiD,IADM,GAEb,CAACjD,MAAM,CAACiD,IAAR,CAFY,EAEGxC,GAFH,CAEO0B,IAAI,IAAIA,IAAI,CAACa,QAAL,EAFf,CAAhB;AAGAlB,MAAAA,OAAO,GAAGA,OAAO,CAACrC,MAAR,CAAeS,GAAG,IAAIqC,QAAQ,CAACrC,GAAD,EAAM,MAAN,EAAc2C,OAAd,CAA9B,CAAV;AACD;;AAED,QAAI7C,MAAM,CAACkD,KAAP,KAAiBjD,SAArB,EAAgC;AAC9B,YAAMkD,OAAO,GAAGnD,MAAM,CAACkD,KAAvB;AACApB,MAAAA,OAAO,GAAGA,OAAO,CAACrC,MAAR,CAAeS,GAAG,IAAI,CAACiD,OAAO,CAACvC,QAAR,CAAiBV,GAAjB,CAAvB,CAAV;AACD;;AAED,QAAIF,MAAM,CAACoD,KAAP,KAAiBnD,SAArB,EAAgC;AAC9B,YAAM4C,OAAO,GAAG7C,MAAM,CAACoD,KAAvB;AACA,YAAMC,SAAS,GAAG/C,OAAO,CAACE,OAAR,CAAgBf,MAAhB,CAAuBS,GAAG,IAAI2C,OAAO,CAACjC,QAAR,CAAiBV,GAAjB,CAA9B,CAAlB;AACA4B,MAAAA,OAAO,GAAGA,OAAO,CAACwB,MAAR,CAAeD,SAAf,CAAV;AACD;;AACD,QAAIE,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAepD,OAAf,CAAX,CAAf;AACAiD,IAAAA,QAAQ,CAAC/C,OAAT,GAAmBsB,OAAnB;AACA,UAAM6B,OAAO,GAAG,MAAMf,QAAQ,CAACW,QAAD,CAA9B;AACA,UAAM5C,IAAI,GAAGgD,OAAO,CAAC9C,UAArB;AACA1B,IAAAA,OAAO,CAAC0B,UAAR,GAAqBF,IAArB;AACA,WAAOxB,OAAP;AACD,GA7CD;AA8CD;;AAEDyE,MAAM,CAACC,OAAP,GAAiB5E,OAAjB","sourcesContent":["const getMod = require('./nusmods').getMod;\nconst assert = require('assert');\nconst parseMod = require('./parseMod');\nconst filterMods = require('./filterMods');\n\nfunction compile(ruleTag) {\n  if (typeof ruleTag == 'object') { \n    let ruleObj = ruleTag;\n    if (ruleObj.func === 'planned') {\n      return planned(ruleObj);\n    } else if (ruleObj.func === 'and') {\n      return and(ruleObj);\n    } else if (ruleObj.func === 'or') {\n      return or(ruleObj);\n    } else if (ruleObj.func === 'mcs') {\n      return mcs(ruleObj);\n    } else if (ruleObj.func === 'filter') {\n      return filter(ruleObj);\n    } else if (ruleObj.func === 'notEmpty') {\n      return notEmpty(ruleObj);\n    } else if (ruleObj.func === 'nTrue') {\n      return nTrue(ruleObj);\n    } else if (ruleObj.func === 'nModules') {\n      return nModules(ruleObj);\n    } else {\n      throw(`func not recognised: ${ruleObj.func} in ${ruleObj.tag}`);\n    }\n  } else {\n    console.error('unrecognised ruleTag');\n  }\n}\n\n//Returns true if the mods listed contains the specified module\nfunction planned(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['moduleCode'] !== undefined);\n  const mod = params.moduleCode;\n  const noSuffix = parseMod(mod).no_suffix;\n  return (modPlan) => {\n    const noSuffixList = modPlan.modules.map(code => parseMod(code).no_suffix);\n    const bool = noSuffixList.includes(noSuffix);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }  \n}\n\n//Returns true if all of the sub functions return true\nasync function and(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['list'] !== undefined, '\"and\" list not provided');\n  const list = params.list;\n  var funcArray = await Promise.all(list.map(compile));\n  return async (modPlan) => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const bool = boolArray.every(bool => bool);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }\n}\n\n//Returns true if at least one of the sub function returns true\nasync function or(ruleObj) {\n  var params = ruleObj.params\n  assert(params['list'] !== undefined);\n  const list = params.list;\n  var funcArray = await Promise.all(list.map(compile));\n  return async (modPlan) => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const bool = boolArray.includes(true);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }\n}\n\n//Returns true if at least n of the sub functions return true, and less than or\n//equal to max of the sub functions return true\nasync function nTrue(ruleObj) {\n  var params = ruleObj.params;\n\n  // Assert that at least one criteria is specified\n  assert(params['list'] !== undefined);\n  assert(\n    params['min'] !== undefined || \n    params['max'] !== undefined || \n    params['equal'] !== undefined);\n\n  // Parse and set the constraints\n  var min, max, equal;\n  if (params.min) {\n    min = typeof params.min == 'string'\n    ? parseInt(params.min)\n    : params.min\n  }\n  if (params.max) {\n    max = typeof params.max == 'string'\n    ? parseInt(params.max)\n    : params.max\n  }\n  if (params.equal) {\n    equal = typeof params.equal == 'string'\n    ? parseInt(params.equal)\n    : params.equal\n  }\n\n  const list = params.list\n  var funcArray = await Promise.all(list.map(compile));\n  return async (modPlan) => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const n = boolArray.reduce((a, b) => a + b, 0);\n\n    if (min !== undefined && n < min) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    } \n    if (max !== undefined && n > max) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    } \n    if (equal !== undefined && n !== equal) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    } \n    ruleObj.evaluation = true;\n    return ruleObj;\n\n  }\n}\n\n//Returns true if the mods listed meet the number of MCs stated\nasync function mcs(ruleObj) {\n  var params = ruleObj.params;\n\n  assert(\n    params['min'] !== undefined || \n    params['max'] !== undefined || \n    params['equal'] !== undefined);\n  // Parse and set the constraints\n  var min, max, equal;\n  if (params.min) {\n    min = typeof params.min == 'string'\n    ? parseInt(params.min)\n    : params.min\n  }\n  if (params.max) {\n    max = typeof params.max == 'string'\n    ? parseInt(params.max)\n    : params.max\n  }\n  if (params.equal) {\n    equal = typeof params.equal == 'string'\n    ? parseInt(params.equal)\n    : params.equal\n  }\n\n  return async (modPlan) => {\n    var modList = modPlan.modules;\n    if (params.filter !== undefined) {\n      if (Array.isArray(params.filter)) {\n        modList = filterMods(modList, ...params.filter);\n      } else if (typeof params.filter == 'object') {\n        modList = filterMods(modList, params.filter);\n      }\n    }\n    const promiseArr = modList.map(code => getMod(2018, code));\n    const creditArr = await Promise.all(promiseArr);\n    const n = creditArr.map(item => parseInt(item.moduleCredit)).reduce((a, b) => a + b, 0);\n\n    if (min !== undefined && n < min) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    } \n    if (max !== undefined && n > max) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    } \n    if (equal !== undefined && n !== equal) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    } \n    ruleObj.evaluation = true;\n    return ruleObj;\n\n  }\n}\n\n//Checks if the modPlan contains at least n number of modules\nasync function nModules (ruleObj) {\n  var params = ruleObj.params;\n\n  assert(\n    params['min'] !== undefined || \n    params['max'] !== undefined || \n    params['equal'] !== undefined, \"in \" + ruleObj);\n  // Parse and set the constraints\n  var min, max, equal;\n  if (params.min) {\n    min = typeof params.min == 'string'\n    ? parseInt(params.min)\n    : params.min\n  }\n  if (params.max) {\n    max = typeof params.max == 'string'\n    ? parseInt(params.max)\n    : params.max\n  }\n  if (params.equal) {\n    equal = typeof params.equal == 'string'\n    ? parseInt(params.equal)\n    : params.equal\n  }\n\n  return (modPlan) => {\n    var filteredModules = modPlan.modules;\n    if (params.filter !== undefined) {\n      if (Array.isArray(params.filter)) {\n        filteredModules = filterMods(filteredModules, ...params.filter);\n      } else if (typeof params.filter == 'object') {\n        filteredModules = filterMods(filteredModules, params.filter);\n      }\n    }\n    const n = filteredModules.length;\n\n    if (min !== undefined && n < min) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    } \n    if (max !== undefined && n > max) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    } \n    if (equal !== undefined && n !== equal) {\n      ruleObj.evaluation = false;\n      return ruleObj;\n    } \n    ruleObj.evaluation = true;\n    return ruleObj;\n\n  }\n}\n\n//Checks if the modPlan is not empty\nasync function notEmpty (ruleObj) {\n  var params = ruleObj.params;\n  return (modPlan) => {\n    var filteredModules = modPlan.modules;\n    if (params.filter !== undefined) {\n      if (Array.isArray(params.filter)) {\n        filteredModules = filterMods(filteredModules, ...params.filter);\n      } else if (typeof params.filter == 'object') {\n        filteredModules = filterMods(filteredModules, params.filter);\n      }\n    }\n    const bool = (filteredModules.length !== 0);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n}\n\n//Filters the modPlan for certain modules and passes it to the next function\n//Filtering happens in the following sequence:\n//First only allow the specified modules\n//Then filter by prefix and level\n//Then reintroduced the excepted modules\nasync function filter(ruleObj) {\n  var params = ruleObj.params;\n\n  function checkFor (moduleCode, attribute, acceptedVals) {\n    let key = parseMod(moduleCode)[attribute];\n    assert(key !== undefined);\n    return acceptedVals.includes(key);\n  }\n\n  assert(params.next !== undefined);\n  var nextFunc = await compile(params.next);\n\n  return async modPlan => {\n    var modList = modPlan.modules;\n\n    if (params.modules !== undefined) {\n      const allowed = params.modules;\n      modList = modList.filter(mod => allowed.includes(mod));\n    }\n\n    if (params.prefix !== undefined) {\n      const allowed = typeof params.prefix === 'string'\n        ? [params.prefix]\n        : params.prefix;\n      modList = modList.filter(mod => checkFor(mod, 'prefix', allowed))\n    }\n\n    if (params.level !== undefined) {\n      const allowed = (typeof params.level === 'object'\n        ? params.level\n        : [params.level]).map(item => item.toString());\n      modList = modList.filter(mod => checkFor(mod, 'level', allowed));\n    }\n\n    if (params.type !== undefined) {\n      const allowed = (typeof params.type === 'object'\n        ? params.type\n        : [params.type]).map(item => item.toString());\n      modList = modList.filter(mod => checkFor(mod, 'type', allowed));\n    }\n\n    if (params.block !== undefined) {\n      const blocked = params.block;\n      modList = modList.filter(mod => !blocked.includes(mod));\n    }\n\n    if (params.allow !== undefined) {\n      const allowed = params.allow;\n      const exception = modPlan.modules.filter(mod => allowed.includes(mod));\n      modList = modList.concat(exception);\n    }\n    var deepCopy = JSON.parse(JSON.stringify(modPlan));\n    deepCopy.modules = modList;\n    const nextObj = await nextFunc(deepCopy);\n    const bool = nextObj.evaluation;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }\n}\n\nmodule.exports = compile;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"const getMod = require('./nusmods').getMod;\n\nconst assert = require('assert');\n\nconst parseMod = require('./parseMod');\n\nconst filterMods = require('./filterMods');\n\nfunction compile(ruleTag) {\n  if (typeof ruleTag == 'object') {\n    ruleObj = ruleTag;\n\n    if (ruleObj.func === 'planned') {\n      return planned(ruleObj);\n    } else if (ruleObj.func === 'and') {\n      return and(ruleObj);\n    } else if (ruleObj.func === 'or') {\n      return or(ruleObj);\n    } else if (ruleObj.func === 'mcs') {\n      return mcs(ruleObj);\n    } else if (ruleObj.func === 'filter') {\n      return filter(ruleObj);\n    } else if (ruleObj.func === 'notEmpty') {\n      return notEmpty(ruleObj);\n    } else if (ruleObj.func === 'nTrue') {\n      return nTrue(ruleObj);\n    } else if (ruleObj.func === 'nModules') {\n      return nModules(ruleObj);\n    } else {\n      throw `func not recognised: ${ruleObj.func} in ${ruleObj.tag}`;\n    }\n  } else {\n    console.error('unrecognised ruleTag');\n  }\n} //Returns true if the mods listed contains the specified module\n\n\nfunction planned(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['moduleCode'] !== undefined);\n  const mod = params.moduleCode;\n  const noSuffix = parseMod(mod).no_suffix;\n  return modPlan => {\n    const noSuffixList = modPlan.modules.map(str => parseMod(str).no_suffix);\n    const bool = noSuffixList.includes(noSuffix);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Returns true if all of the sub functions return true\n\n\nasync function and(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['list'] !== undefined, '\"and\" list not provided');\n  const expandedList = params.list;\n  var funcArray = await Promise.all(expandedList.map(compile));\n  return async modPlan => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const bool = boolArray.every(bool => bool);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Returns true if at least one of the sub function returns true\n\n\nasync function or(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['list'] !== undefined);\n  const expandedList = params.list;\n  var funcArray = await Promise.all(expandedList.map(compile));\n  return async modPlan => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const bool = boolArray.includes(true);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Returns true if at least n of the sub functions return true, and less than or\n//equal to max of the sub functions return true\n\n\nasync function nTrue(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['list'] !== undefined);\n  assert(params['n'] !== undefined || params['max'] !== undefined);\n  const n = typeof params.n == 'string' ? parseInt(params.n) : params.n;\n\n  if (params.max) {\n    const max = typeof params.max == 'string' ? parseInt(params.max) : params.max;\n  }\n\n  const expandedList = await params.list;\n  var funcArray = await Promise.all(expandedList.map(compile));\n  return async modPlan => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const numOfMods = boolArray.reduce((a, b) => a + b, 0);\n    const bool = numOfMods >= n;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Returns true if the mods listed meet the number of MCs stated\n\n\nasync function mcs(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['n'] !== undefined);\n  const mcLimit = typeof params.n === 'number' ? params.n : parseInt(params.n);\n  return async modPlan => {\n    var modList = modPlan.modules;\n\n    if (params.filter !== undefined) {\n      if (Array.isArray(params.filter)) {\n        modList = filterMods(modList, ...params.filter);\n      } else if (typeof params.filter == 'object') {\n        modList = filterMods(modList, params.filter);\n      }\n    }\n\n    const promiseArr = modList.map(code => getMod(2018, code));\n    const creditArr = await Promise.all(promiseArr);\n    const total = creditArr.map(item => parseInt(item.moduleCredit)).reduce((a, b) => a + b, 0);\n    const bool = total >= mcLimit;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Checks if the modPlan contains at least n number of modules\n\n\nasync function nModules(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['n'] !== undefined);\n  return modPlan => {\n    var filteredModules = modPlan.modules;\n\n    if (params.filter !== undefined) {\n      if (Array.isArray(params.filter)) {\n        filteredModules = filterMods(filteredModules, ...params.filter);\n      } else if (typeof params.filter == 'object') {\n        filteredModules = filterMods(filteredModules, params.filter);\n      }\n    }\n\n    const bool = filteredModules.length >= params.n;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Checks if the modPlan is not empty\n\n\nasync function notEmpty(ruleObj) {\n  var params = ruleObj.params;\n  return modPlan => {\n    const bool = modPlan.modules.length !== 0;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n} //Filters the modPlan for certain modules and passes it to the next function\n//Filtering happens in the following sequence:\n//First only allow the specified modules\n//Then filter by prefix and level\n//Then reintroduced the excepted modules\n\n\nasync function filter(ruleObj) {\n  var params = ruleObj.params;\n\n  function checkFor(moduleCode, attribute, acceptedVals) {\n    key = parseMod(moduleCode)[attribute];\n    assert(key !== undefined);\n    return acceptedVals.includes(key);\n  }\n\n  assert(params.next !== undefined);\n  var nextFunc = await compile(params.next);\n  return async modPlan => {\n    var modList = modPlan.modules;\n\n    if (params.modules !== undefined) {\n      const allowed = params.modules;\n      modList = modList.filter(mod => allowed.includes(mod));\n    }\n\n    if (params.prefix !== undefined) {\n      const allowed = typeof params.prefix === 'string' ? [params.prefix] : params.prefix;\n      modList = modList.filter(mod => checkFor(mod, 'prefix', allowed));\n    }\n\n    if (params.level !== undefined) {\n      const allowed = (typeof params.level === 'object' ? params.level : [params.level]).map(item => item.toString());\n      modList = modList.filter(mod => checkFor(mod, 'level', allowed));\n    }\n\n    if (params.type !== undefined) {\n      const allowed = (typeof params.type === 'object' ? params.type : [params.type]).map(item => item.toString());\n      modList = modList.filter(mod => checkFor(mod, 'type', allowed));\n    }\n\n    if (params.block !== undefined) {\n      const blocked = params.block;\n      modList = modList.filter(mod => !blocked.includes(mod));\n    }\n\n    if (params.allow !== undefined) {\n      const allowed = params.allow;\n      const exception = modPlan.modules.filter(mod => allowed.includes(mod));\n      modList = modList.concat(exception);\n    }\n\n    var deepCopy = JSON.parse(JSON.stringify(modPlan));\n    deepCopy.modules = modList;\n    const nextObj = await nextFunc(deepCopy);\n    const bool = nextObj.evaluation;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n}\n\nmodule.exports = compile;","map":{"version":3,"sources":["/Users/frisciliasultan/Documents/Orbitalhosting/src/backend_utils/compile.js"],"names":["getMod","require","assert","parseMod","filterMods","compile","ruleTag","ruleObj","func","planned","and","or","mcs","filter","notEmpty","nTrue","nModules","tag","console","error","params","undefined","mod","moduleCode","noSuffix","no_suffix","modPlan","noSuffixList","modules","map","str","bool","includes","evaluation","expandedList","list","funcArray","Promise","all","objArray","boolArray","obj","every","n","parseInt","max","numOfMods","reduce","a","b","mcLimit","modList","Array","isArray","promiseArr","code","creditArr","total","item","moduleCredit","filteredModules","length","checkFor","attribute","acceptedVals","key","next","nextFunc","allowed","prefix","level","toString","type","block","blocked","allow","exception","concat","deepCopy","JSON","parse","stringify","nextObj","module","exports"],"mappings":"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","sourcesContent":["const getMod = require('./nusmods').getMod;\nconst assert = require('assert');\nconst parseMod = require('./parseMod');\nconst filterMods = require('./filterMods');\n\nfunction compile(ruleTag) {\n  if (typeof ruleTag == 'object') { \n    ruleObj = ruleTag;\n    if (ruleObj.func === 'planned') {\n      return planned(ruleObj);\n    } else if (ruleObj.func === 'and') {\n      return and(ruleObj);\n    } else if (ruleObj.func === 'or') {\n      return or(ruleObj);\n    } else if (ruleObj.func === 'mcs') {\n      return mcs(ruleObj);\n    } else if (ruleObj.func === 'filter') {\n      return filter(ruleObj);\n    } else if (ruleObj.func === 'notEmpty') {\n      return notEmpty(ruleObj);\n    } else if (ruleObj.func === 'nTrue') {\n      return nTrue(ruleObj);\n    } else if (ruleObj.func === 'nModules') {\n      return nModules(ruleObj);\n    } else {\n      throw(`func not recognised: ${ruleObj.func} in ${ruleObj.tag}`);\n    }\n  } else {\n    console.error('unrecognised ruleTag');\n  }\n}\n\n//Returns true if the mods listed contains the specified module\nfunction planned(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['moduleCode'] !== undefined);\n  const mod = params.moduleCode;\n  const noSuffix = parseMod(mod).no_suffix;\n  return (modPlan) => {\n    const noSuffixList = modPlan.modules.map(str => parseMod(str).no_suffix);\n    const bool = noSuffixList.includes(noSuffix);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }  \n}\n\n//Returns true if all of the sub functions return true\nasync function and(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['list'] !== undefined, '\"and\" list not provided');\n  const expandedList = params.list;\n  var funcArray = await Promise.all(expandedList.map(compile));\n  return async (modPlan) => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const bool = boolArray.every(bool => bool);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }\n}\n\n//Returns true if at least one of the sub function returns true\nasync function or(ruleObj) {\n  var params = ruleObj.params\n  assert(params['list'] !== undefined);\n  const expandedList = params.list;\n  var funcArray = await Promise.all(expandedList.map(compile));\n  return async (modPlan) => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const bool = boolArray.includes(true);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }\n}\n\n//Returns true if at least n of the sub functions return true, and less than or\n//equal to max of the sub functions return true\nasync function nTrue(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['list'] !== undefined);\n  assert(params['n'] !== undefined || params['max'] !== undefined);\n  const n = typeof params.n == 'string'\n    ? parseInt(params.n)\n    : params.n\n  if (params.max) {\n    const max = typeof params.max == 'string'\n    ? parseInt(params.max)\n    : params.max\n  }\n  const expandedList = await params.list\n  var funcArray = await Promise.all(expandedList.map(compile));\n  return async (modPlan) => {\n    var objArray = await Promise.all(funcArray.map(func => func(modPlan)));\n    const boolArray = objArray.map(obj => obj.evaluation);\n    const numOfMods = boolArray.reduce((a, b) => a + b, 0)\n    const bool = numOfMods >= n;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }\n}\n\n//Returns true if the mods listed meet the number of MCs stated\nasync function mcs(ruleObj) {\n  var params = ruleObj.params;\n  assert(params['n'] !== undefined);\n  const mcLimit = typeof params.n === 'number'\n    ? params.n\n    : parseInt(params.n);\n  return async (modPlan) => {\n    var modList = modPlan.modules;\n    if (params.filter !== undefined) {\n      if (Array.isArray(params.filter)) {\n        modList = filterMods(modList, ...params.filter);\n      } else if (typeof params.filter == 'object') {\n        modList = filterMods(modList, params.filter);\n      }\n    }\n    const promiseArr = modList.map(code => getMod(2018, code));\n    const creditArr = await Promise.all(promiseArr);\n    const total = creditArr.map(item => parseInt(item.moduleCredit)).reduce((a, b) => a + b, 0);\n    const bool = total >= mcLimit;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }\n}\n\n//Checks if the modPlan contains at least n number of modules\nasync function nModules (ruleObj) {\n  var params = ruleObj.params;\n  assert(params['n'] !== undefined);\n\n  return (modPlan) => {\n    var filteredModules = modPlan.modules;\n    if (params.filter !== undefined) {\n      if (Array.isArray(params.filter)) {\n        filteredModules = filterMods(filteredModules, ...params.filter);\n      } else if (typeof params.filter == 'object') {\n        filteredModules = filterMods(filteredModules, params.filter);\n      }\n    }\n    const bool = filteredModules.length >= params.n;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }\n}\n\n//Checks if the modPlan is not empty\nasync function notEmpty (ruleObj) {\n  var params = ruleObj.params;\n  return (modPlan) => {\n    const bool = (modPlan.modules.length !== 0);\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  };\n}\n\n//Filters the modPlan for certain modules and passes it to the next function\n//Filtering happens in the following sequence:\n//First only allow the specified modules\n//Then filter by prefix and level\n//Then reintroduced the excepted modules\nasync function filter(ruleObj) {\n  var params = ruleObj.params;\n\n  function checkFor (moduleCode, attribute, acceptedVals) {\n    key = parseMod(moduleCode)[attribute];\n    assert(key !== undefined);\n    return acceptedVals.includes(key);\n  }\n\n  assert(params.next !== undefined);\n  var nextFunc = await compile(params.next);\n\n  return async modPlan => {\n    var modList = modPlan.modules;\n\n    if (params.modules !== undefined) {\n      const allowed = params.modules;\n      modList = modList.filter(mod => allowed.includes(mod));\n    }\n\n    if (params.prefix !== undefined) {\n      const allowed = typeof params.prefix === 'string'\n        ? [params.prefix]\n        : params.prefix;\n      modList = modList.filter(mod => checkFor(mod, 'prefix', allowed))\n    }\n\n    if (params.level !== undefined) {\n      const allowed = (typeof params.level === 'object'\n        ? params.level\n        : [params.level]).map(item => item.toString());\n      modList = modList.filter(mod => checkFor(mod, 'level', allowed));\n    }\n\n    if (params.type !== undefined) {\n      const allowed = (typeof params.type === 'object'\n        ? params.type\n        : [params.type]).map(item => item.toString());\n      modList = modList.filter(mod => checkFor(mod, 'type', allowed));\n    }\n\n    if (params.block !== undefined) {\n      const blocked = params.block;\n      modList = modList.filter(mod => !blocked.includes(mod));\n    }\n\n    if (params.allow !== undefined) {\n      const allowed = params.allow;\n      const exception = modPlan.modules.filter(mod => allowed.includes(mod));\n      modList = modList.concat(exception);\n    }\n    var deepCopy = JSON.parse(JSON.stringify(modPlan));\n    deepCopy.modules = modList;\n    const nextObj = await nextFunc(deepCopy);\n    const bool = nextObj.evaluation;\n    ruleObj.evaluation = bool;\n    return ruleObj;\n  }\n}\n\nmodule.exports = compile;"]},"metadata":{},"sourceType":"module"}